{"version":3,"sources":["webpack:///./src/parser/query-helper.ts","webpack:///./src/parser/grouping.ts","webpack:///./src/parser/column-reference-parser.ts","webpack:///./node_modules/guid-typescript/dist/guid.js","webpack:///./src/parser/showplan.ts","webpack:///./src/parser/convert.ts"],"names":["__webpack_require__","d","__webpack_exports__","QueryHelper","GetImmediateChildNodesByTagName","node","tagName","returnNodes","returnCounter","children","childNodes","nodeCounter","length","nodeType","GetAllImmediateChildNodes","ParseSingleItem","element","process","objectElements","this","ParseAllItems","map","i","Group","key","members","Grouper","groupBy","list","func","group","res","forEach","o","groupName","undefined","push","column_reference_parser_ColumnReferenceParser","ColumnReferenceParser","Parse","column","convert","GetString","columnReference","showplan","Server","Database","Schema","Table","Alias","ComputedColumn","GetBoolean","ParameterDataType","ParameterCompiledValue","ParameterRuntimeValue","GetAllFromElement","parentElement","elementName","_this","containerElement","query_helper","columnReferenceElements","columns","a","exports","__esModule","Guid","guid","TypeError","value","EMPTY","isGuid","toString","validator","test","create","gen","join","createEmpty","parse","raw","count","out","Math","random","substring","prototype","equals","other","isEmpty","toJSON","RegExp","ShowPlanXML","Build","ClusteredMode","Version","Batches","GetStatementByGuid","_i","_a","batch","_b","_c","Statements","statement","IsEstimatedPlan","StmtSimple","queryPlan","QueryPlan","RelOp","RunTimeInformation","RelOpAction","Action","AvgRowSize","EstimateCPU","EstimatedTotalSubtreeCost","EstimateIO","EstimateRebinds","EstimateRewinds","EstimateRows","LogicalOp","NodeId","Parallel","PhysicalOperation","OutputList","PhysicalOp","Object","defineProperty","sum","relOp","estimate","expandedComputedColumns","GetExpandedComputedColumns","replaceAll","Index","GetChildExpandedComputedColumns","childExpanded","concat","ExpandedComputedColumns","expand","definedValue","childColumns","ScalarOperator","ScalarString","ColumnReference","columnRef","expanded","childColumns_1","child","Column","Value","ExpandedComputedColumn","DefinedValues","expandedChild","findIndex","Rowset","_super","object","call","tslib__WEBPACK_IMPORTED_MODULE_0__","AdaptiveJoin","optimized","Optimized","AffectingConvertWarning","convertIssue","expression","ConvertIssue","Expression","Aggregate","AggType","Distinct","Arithmetic","Operation","Assign","ColumnRef","BaseStmtInfo","guid_typescript__WEBPACK_IMPORTED_MODULE_1__","CostPercentOfBatch","Batch","StatementSubTreeCost","total","filter","reduce","current","BatchHashTableBuild","Bitmap","hashKeys","HashKeys","CLRFunction","$class","Class","Collapse","GroupBy","ColumnGroup","usage","Usage","ColumnName","columnId","name","ColumnId","Name","CompareType","compareOp","scalarOperator","CompareOp","ComputeScalar","Concat","Conditional","condition","$else","then","Condition","Else","Then","ConstantScan","Const","constValue","ConstValue","Convert","dataType","implicit","style","DataType","Implicit","Style","CreateIndex","DefinedValue","Filter","StartupExpression","Predicate","ForeignKeyReferenceCheck","indexScan","IndexScan","ForeignKeyReferencesCheck","foreignKeyReferenceCheck","Generic","HashSpillDetails","Hash","Ident","table","ordered","Ordered","Intrinsic","functionName","FunctionName","Logical","operation","MemoryGrant","serialDesiredMemory","serialRequiredMemory","SerialDesiredMemory","SerialRequiredMemory","MemoryGrantWarningInfo","grantedMemory","grantWarningKind","maxUsedMemory","requestedMemory","GrantedMemory","GrantWarningKind","MaxUsedMemory","RequestedMemory","Merge","MissingIndexes","missingIndexGroup","MissingIndexGroup","impact","missingIndex","Impact","MissingIndex","database","schema","columnGroup","toCreateIndexString","includeColumnNames","equalityColumnNames","col","includeColumns","indexName","sql","MultiAssign","assigns","Assigns","NestedLoops","ObjectType","getFullTableName","OptimizerHardwareDependentProperties","EstimatedAvailableMemoryGrant","EstimatedPagesCached","OptimizerStatsUsage","statisticsInfo","StatisticsInfo","OrderBy","orderByColumn","OrderByColumn","OrderByTypeOrderByColumn","ascending","Ascending","Parallelism","QueryExecTime","cpuTime","elapsedTime","CpuTime","ElapsedTime","RelOperation","ReceivePlan","ReceivePlanTypeOperation","pperationType","OperationType","Remote","RemoteFetch","RemoteModify","RemoteQuery","RemoteRange","Put","RollupInfo","highestLevel","rollupLevel","HighestLevel","RollupLevel","level","Level","runTimeCountersPerThread","RunTimeCountersPerThread","GetRunTimeCountersSummary","b","RunTimeInformationTypeRunTimeCountersPerThread","ActualEndOfScans","ActualRows","ActualExecutions","ActualCPUms","undefinedAdd","ActualElapsedms","ActualLobLogicalReads","ActualLobPhysicalReads","ActualLobReadAheads","ActualLocallyAggregatedRows","ActualLogicalReads","ActualPhysicalReads","ActualReadAheads","ActualRebinds","ActualRewinds","ActualRowsRead","ActualScans","actualEndOfScans","actualRows","thread","actualExecutions","Thread","RunTimePartitionSummaryTypePartitionsAccessed","PartitionCount","RunTimePartitionSummaryTypePartitionsAccessedTypePartitionRange","End","Start","ScalarExpressionList","ScalarExpression","ScalarInsert","ScalarSequence","NotImplementedScalarOp","Scalar","ScanRange","scanType","rangeColumns","rangeExpressions","ScanType","RangeColumns","RangeExpressions","ScanTypeToString","SeekPredicateNew","seekKeys","SeekKeys","SeekPredicatePart","seekPredicateNew","SeekPredicates","SeekPredicate","toStrings","result","Prefix","StartRange","EndRange","IsNotNull","Segment","segmentColumn","SegmentColumn","Sequence","SetOptions","ANSI_NULLS","ANSI_PADDING","ANSI_WARNINGS","ARITHABORT","CONCAT_NULL_YIELDS_NULL","NUMERIC_ROUNDABORT","QUOTED_IDENTIFIER","SetPredicateElement","ShowPlanXMLTypeBatchSequenceTypeBatch","TotalCost","SimpleIteratorOneChild","SimpleUpdate","SortSpillDetails","Sort","distinct","orderBy","SpillToTempDb","Split","Spool","StarJoinInfo","operationType","StatsInfo","modificationCount","samplingPercent","statistics","ModificationCount","SamplingPercent","Statistics","StmtCond","StmtCondTypeCondition","StmtCondTypeElse","statements","StmtCondTypeThen","StmtCursor","cursorPlan","CursorPlan","StmtReceive","receivePlan","StmtUseDb","StreamAggregate","Subquery","relop","Switch","TableScan","TableValuedFunction","ThreadReservation","ReservedThreads","ThreadStat","Branches","TopSort","rows","Rows","Top","UDAggregate","UDF","UDTMethod","UDX","udxName","UDXName","Update","WaitStatList","WaitStat","waitCount","waitTimeMs","waitType","WaitCount","WaitTimeMs","WaitType","WaitWarning","Warnings","WindowAggregate","Window","GetFloat","attribute","input","getAttribute","parseFloat","GetInt","parseInt","GetDate","Date"],"mappings":"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","file":"js/chunk-6f55d68d.a5d222b8.js","sourcesContent":["export class QueryHelper {\n  public static GetImmediateChildNodesByTagName(node: Element, tagName: string): Element[] {\n    const returnNodes: Element[] = [];\n    let returnCounter = 0;\n    const children = node.childNodes;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let nodeCounter = 0; nodeCounter < children.length; nodeCounter++) {\n      if (children[nodeCounter].nodeType !== 1) {\n        continue;\n      }\n      if ((children[nodeCounter] as Element).tagName === tagName) {\n        returnNodes[returnCounter] = children[nodeCounter] as Element;\n        returnCounter++;\n      }\n    }\n\n    return returnNodes;\n  }\n\n  public static GetAllImmediateChildNodes(node: Element): Element[] {\n    const returnNodes: Element[] = [];\n    let returnCounter = 0;\n    const children = node.childNodes;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let nodeCounter = 0; nodeCounter < children.length; nodeCounter++) {\n      if (children[nodeCounter].nodeType !== 1) {\n        continue;\n      }\n\n      returnNodes[returnCounter] = children[nodeCounter] as Element;\n      returnCounter++;\n    }\n\n    return returnNodes;\n  }\n\n  public static ParseSingleItem<T>(\n    element: Element,\n    tagName: string,\n    process: (element: Element) => T,\n  ): T | undefined {\n    const objectElements = this.GetImmediateChildNodesByTagName(element, tagName);\n    if (objectElements.length === 1) {\n      return process(objectElements[0]);\n    }\n\n    return undefined;\n  }\n\n  public static ParseAllItems<T>(\n    element: Element,\n    tagName: string,\n    process: (element: Element) => T,\n  ): T[] | undefined {\n    const objectElements = this.GetImmediateChildNodesByTagName(element, tagName);\n    if (objectElements.length === 0) {\n      return undefined;\n    }\n\n    return objectElements.map((i) => process(i));\n  }\n}\n","export class Group<T> {\n  public key: string;\n  public members: T[] = [];\n  constructor(key: string) {\n    this.key = key;\n  }\n}\n\nexport class Grouper  {\n  public static groupBy<T>(list: T[], func: (x: T) => string): Array<Group<T>> {\n    const res: Array<Group<T>> = [];\n    let group: Group<T> | undefined;\n\n    list.forEach((o) => {\n      const groupName = func(o);\n      if (group === undefined) {\n        group = new Group<T>(groupName);\n      }\n      if (groupName !== group.key) {\n        res.push(group);\n        group = new Group<T>(groupName);\n      }\n      group.members.push(o);\n    });\n\n    if (group !== undefined) {\n      res.push(group);\n    }\n    return res;\n  }\n}\n","import * as ShowPlan from './showplan';\nimport { Convert } from './convert';\nimport { QueryHelper } from './query-helper';\nimport { ColumnReference } from './showplan';\nimport { Grouper, Group } from './grouping';\n\nexport class ColumnReferenceParser {\n  public static Parse(element: Element): ShowPlan.ColumnReference {\n    const column = Convert.GetString(element, 'Column') as string;\n    const columnReference = new ShowPlan.ColumnReference(column);\n\n    columnReference.Server = Convert.GetString(element, 'Server');\n    columnReference.Database = Convert.GetString(element, 'Database');\n    columnReference.Schema = Convert.GetString(element, 'Schema');\n    columnReference.Table = Convert.GetString(element, 'Table');\n    columnReference.Alias = Convert.GetString(element, 'Alias');\n    columnReference.ComputedColumn = Convert.GetBoolean(element, 'ComputedColumn');\n    columnReference.ParameterDataType = Convert.GetString(element, 'ParameterDataType');\n    columnReference.ParameterCompiledValue = Convert.GetString(element, 'ParameterCompiledValue');\n    columnReference.ParameterRuntimeValue = Convert.GetString(element, 'ParameterRuntimeValue');\n\n    // todo set InternalInfo and ScalarOperator\n\n    return columnReference;\n  }\n\n  public static GetAllFromElement(parentElement: Element, elementName: string): ShowPlan.ColumnReference[] {\n    const containerElement = QueryHelper.GetImmediateChildNodesByTagName(parentElement, elementName);\n    if (containerElement.length !== 1) {\n      return [];\n    }\n\n    const columnReferenceElements = QueryHelper.GetImmediateChildNodesByTagName(containerElement[0], 'ColumnReference');\n    return columnReferenceElements.map((i) => this.Parse(i));\n  }\n\n  public static Group(columns: ShowPlan.ColumnReference[]): Array<Group<ColumnReference>> {\n    // return groupBy(columns, (a) => a.Database + '.' + a.Schema + '.' + a.Table);\n    return Grouper.groupBy<ColumnReference>(columns, (a: ShowPlan.ColumnReference) => {\n      if (a.Database !== undefined && a.Schema !== undefined && a.Table !== undefined) {\n        let key = a.Database + '.' + a.Schema + '.' + a.Table;\n        if (a.Alias !== undefined) {\n          key += ' as ' + a.Alias;\n        }\n\n        return key;\n      }\n\n      return '';\n    });\n  }\n\n}\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar Guid = /** @class */ (function () {\r\n    function Guid(guid) {\r\n        if (!guid) {\r\n            throw new TypeError(\"Invalid argument; `value` has no value.\");\r\n        }\r\n        this.value = Guid.EMPTY;\r\n        if (guid && Guid.isGuid(guid)) {\r\n            this.value = guid;\r\n        }\r\n    }\r\n    Guid.isGuid = function (guid) {\r\n        var value = guid.toString();\r\n        return guid && (guid instanceof Guid || Guid.validator.test(value));\r\n    };\r\n    Guid.create = function () {\r\n        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\"));\r\n    };\r\n    Guid.createEmpty = function () {\r\n        return new Guid(\"emptyguid\");\r\n    };\r\n    Guid.parse = function (guid) {\r\n        return new Guid(guid);\r\n    };\r\n    Guid.raw = function () {\r\n        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\");\r\n    };\r\n    Guid.gen = function (count) {\r\n        var out = \"\";\r\n        for (var i = 0; i < count; i++) {\r\n            // tslint:disable-next-line:no-bitwise\r\n            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n        }\r\n        return out;\r\n    };\r\n    Guid.prototype.equals = function (other) {\r\n        // Comparing string `value` against provided `guid` will auto-call\r\n        // toString on `guid` for comparison\r\n        return Guid.isGuid(other) && this.value === other.toString();\r\n    };\r\n    Guid.prototype.isEmpty = function () {\r\n        return this.value === Guid.EMPTY;\r\n    };\r\n    Guid.prototype.toString = function () {\r\n        return this.value;\r\n    };\r\n    Guid.prototype.toJSON = function () {\r\n        return {\r\n            value: this.value\r\n        };\r\n    };\r\n    Guid.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\");\r\n    Guid.EMPTY = \"00000000-0000-0000-0000-000000000000\";\r\n    return Guid;\r\n}());\r\nexports.Guid = Guid;\r\n","import { Guid } from 'guid-typescript';\nimport '@/string-extensions';\n\n/** This is the root element */\nexport class ShowPlanXML {\n  public Build: string;\n  public ClusteredMode?: boolean;\n  public Version: string;\n  public Batches: ShowPlanXMLTypeBatchSequenceTypeBatch[];\n\n  constructor(\n    Build: string,\n    ClusteredMode: boolean,\n    Version: string,\n    Batches: ShowPlanXMLTypeBatchSequenceTypeBatch[],\n  ) {\n    this.Build = Build;\n    this.ClusteredMode = ClusteredMode;\n    this.Version = Version;\n    this.Batches = Batches;\n  }\n\n  public GetStatementByGuid(guid: string): BaseStmtInfo | undefined {\n    for (const batch of this.Batches) {\n      for (const statement of batch.Statements) {\n        if (statement.Guid === guid) {\n           return statement;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  public IsEstimatedPlan(): boolean {\n    for (const batch of this.Batches) {\n      for (const statement of batch.Statements) {\n        if (!(statement instanceof StmtSimple)) { continue; }\n        const queryPlan = (statement as StmtSimple).QueryPlan;\n        if (queryPlan === undefined) { continue; }\n\n        if (queryPlan.RelOp.RunTimeInformation !== undefined) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n}\n\nexport class RelOpAction {\n  public RelOp: RelOp[] = [];\n  public DefinedValues?: DefinedValue[];\n}\n\nexport class RelOp {\n  public AdaptiveThresholdRows?: number;\n  public AvgRowSize: number;\n  public EstimateCPU: number;\n  public EstimatedExecutionMode?: ExecutionModeType;\n  public EstimatedJoinType?: PhysicalOp;\n  public EstimatedRowsRead?: number;\n  public EstimatedTotalSubtreeCost: number;\n  public EstimateIO: number;\n  public get EstimateTotalCost(): number {\n    // one would think this would simply be\n    // return this.EstimateCPU + this.EstimateIO;\n    // but in fact it's the subree cost subtracking the subtree cost of it's children\n\n    if (!this.Action.RelOp.length) {\n      return this.EstimatedTotalSubtreeCost;\n    }\n\n    let sum = 0;\n    for (const relOp of this.Action.RelOp) {\n      sum += relOp.EstimatedTotalSubtreeCost;\n    }\n\n    const estimate = this.EstimatedTotalSubtreeCost - sum;\n    if (estimate > 0) {\n      return estimate;\n    }\n\n    return 0;\n  }\n  public EstimateRebinds: number;\n  public EstimateRewinds: number;\n  public EstimateRows: number;\n  public get ExpandedComputedColumns(): ExpandedComputedColumn[] {\n    if (this.expandedComputedColumns === undefined) {\n      this.expandedComputedColumns = this.GetExpandedComputedColumns();\n    }\n\n    return this.expandedComputedColumns!;\n  }\n  public GroupExecuted?: boolean;\n  public IsAdaptive?: boolean;\n  public LogicalOp: LogicalOpType;\n  public NodeId: number;\n  public Parallel: boolean;\n  public Partitioned?: boolean;\n  public PhysicalOp: PhysicalOp;\n  public RemoteDataAccess?: boolean;\n  public StatsCollectionId?: number;\n  public TableCardinality?: number;\n  public OutputList: ColumnReference[];\n  public RunTimeInformation?: RunTimeInformation;\n  public MemoryFractions?: MemoryFractions;\n  public Action: RelOpAction;\n  public Warnings?: Warnings;\n\n  public get SecondaryDesc(): string {\n    switch (this.PhysicalOp) {\n      case 'Index Scan':\n      case 'Index Seek':\n      case 'Clustered Index Scan':\n      case 'Clustered Index Seek':\n        return (this.Action as IndexScan).Object[0].Table!.replaceAll('[', '').replaceAll(']', '');\n      default:\n        break;\n    }\n\n    return this.LogicalOp;\n  }\n\n  public get ThirdLevelDesc(): string | undefined {\n    switch (this.PhysicalOp) {\n      case 'Index Scan':\n      case 'Index Seek':\n      case 'Clustered Index Scan':\n      case 'Clustered Index Seek':\n        return (this.Action as IndexScan).Object[0].Index!.replaceAll('[', '').replaceAll(']', '');\n      default:\n        break;\n    }\n\n    return undefined;\n  }\n\n  private expandedComputedColumns?: ExpandedComputedColumn[];\n\n  constructor(\n    Action: RelOpAction,\n    AvgRowSize: number,\n    EstimateCPU: number,\n    EstimatedTotalSubtreeCost: number,\n    EstimateIO: number,\n    EstimateRebinds: number,\n    EstimateRewinds: number,\n    EstimateRows: number,\n    LogicalOp: LogicalOpType,\n    NodeId: number,\n    Parallel: boolean,\n    PhysicalOperation: PhysicalOp,\n    OutputList: ColumnReference[],\n  ) {\n    this.Action = Action;\n    this.AvgRowSize = AvgRowSize;\n    this.EstimateCPU = EstimateCPU;\n    this.EstimatedTotalSubtreeCost = EstimatedTotalSubtreeCost;\n    this.EstimateIO = EstimateIO;\n    this.EstimateRebinds = EstimateRebinds;\n    this.EstimateRewinds = EstimateRewinds;\n    this.EstimateRows = EstimateRows;\n    this.LogicalOp = LogicalOp;\n    this.NodeId = NodeId;\n    this.Parallel = Parallel;\n    this.PhysicalOp = PhysicalOperation;\n    this.OutputList = OutputList;\n  }\n\n  public GetChildExpandedComputedColumns(): ExpandedComputedColumn[] {\n    let childExpanded: ExpandedComputedColumn[] = [];\n\n    for (const relOp of this.Action.RelOp) {\n      childExpanded = childExpanded.concat(relOp.ExpandedComputedColumns);\n    }\n\n    return childExpanded;\n  }\n\n  private GetExpandedComputedColumns(): ExpandedComputedColumn[] {\n    let childExpanded: ExpandedComputedColumn[] = [];\n\n    for (const relOp of this.Action.RelOp) {\n      childExpanded = childExpanded.concat(relOp.GetExpandedComputedColumns());\n    }\n\n    const expand = (definedValue: DefinedValue, childColumns: ExpandedComputedColumn[]): ExpandedComputedColumn | undefined => {\n      if (definedValue.ScalarOperator === undefined || definedValue.ScalarOperator.ScalarString === undefined) {\n        // if we can't find a scalar string we have nothing to expand\n        return undefined;\n      }\n\n      if (definedValue.ColumnReference === undefined || definedValue.ColumnReference.length !== 1) {\n        // don't mess with anything with multiple columns or nothing defined\n        return undefined;\n      }\n\n      const columnRef = definedValue.ColumnReference[0];\n\n      if (columnRef.Table !== undefined) {\n        // if we have a table name here then I have no idea what's happened. bail\n        return undefined;\n      }\n\n      let expanded = definedValue.ScalarOperator!.ScalarString!;\n      for (const child of childColumns) {\n        expanded = expanded.replaceAll(child.Column, child.Value);\n      }\n\n      return new ExpandedComputedColumn(columnRef.Column, expanded);\n    };\n\n\n    if (this.Action.DefinedValues !== undefined) {\n      for (const definedValue of this.Action.DefinedValues) {\n        const expandedChild = expand(definedValue, childExpanded);\n        if (expandedChild !== undefined) {\n          // not sure what happenes here with columns referencing themselves in later\n          if (childExpanded.findIndex((i) => i.Column === expandedChild.Column) === -1) {\n            childExpanded.push(expandedChild);\n          }\n        }\n      }\n    }\n\n\n    return childExpanded;\n  }\n}\n\nexport class ExpandedComputedColumn {\n  public Column: string;\n  public Value: string;\n\n  constructor(column: string, value: string) {\n    this.Column = column;\n    this.Value = value;\n  }\n}\n\nexport class Rowset extends RelOpAction {\n  public Object: ObjectType[];\n\n  constructor(object: ObjectType[]) {\n    super();\n    this.Object = object;\n  }\n}\n\n/** The Adaptive Join element replaces a adaptive concat with Hash Join and Nested loops as inputs. This element\n * will have 3 inputs the two children of the HJ and the inner child of the NLJ. We append the required HJ and NLJ properties to the new\n * AdaptiveJoin showplan element.\n */\nexport class AdaptiveJoin extends RelOpAction {\n  public BitmapCreator?: boolean;\n  public Optimized: boolean;\n  public BuildResidual?: ScalarExpression;\n  public HashKeysBuild?: ColumnReference[];\n  public HashKeysProbe?: ColumnReference[];\n  public OuterReferences?: ColumnReference[];\n  public PartitionId?: ColumnReference;\n  public PassThru?: ScalarExpression;\n  public Predicate?: ScalarExpression;\n  public ProbeResidual?: ScalarExpression;\n  public StarJoinInfo?: StarJoinInfo;\n\n  constructor(optimized: boolean) {\n    super();\n    this.Optimized = optimized;\n  }\n}\n\n/** Warning information for plan-affecting type conversion */\nexport class AffectingConvertWarning {\n  public ConvertIssue: AffectingConvertWarningTypeConvertIssue;\n  public Expression: string;\n\n  constructor(convertIssue: AffectingConvertWarningTypeConvertIssue, expression: string) {\n    this.ConvertIssue = convertIssue;\n    this.Expression = expression;\n  }\n}\n\nexport type AffectingConvertWarningTypeConvertIssue = 'Cardinality Estimate' | 'Seek Plan';\n\nexport class Aggregate implements ScalarOp {\n  public AggType: string;\n  public Distinct: boolean;\n  public ScalarOperator?: Scalar[];\n\n  constructor(AggType: string, Distinct: boolean) {\n    this.AggType = AggType;\n    this.Distinct = Distinct;\n  }\n}\n\nexport type ArithmeticOperation =\n  | 'ADD'\n  | 'BIT_ADD'\n  | 'BIT_AND'\n  | 'BIT_COMBINE'\n  | 'BIT_NOT'\n  | 'BIT_OR'\n  | 'BIT_XOR'\n  | 'DIV'\n  | 'HASH'\n  | 'MINUS'\n  | 'MOD'\n  | 'MULT'\n  | 'SUB';\n\nexport class Arithmetic implements ScalarOp {\n  public Operation: ArithmeticOperation;\n  public ScalarOperator: Scalar[];\n\n  constructor(Operation: ArithmeticOperation, ScalarOperator: Scalar[]) {\n    this.Operation = Operation;\n    this.ScalarOperator = ScalarOperator;\n  }\n}\n\nexport class Assign implements ScalarOp {\n  public ColumnReference: ColumnReference;\n  public ScalarOperator: Scalar;\n\n  constructor(ColumnRef: ColumnReference, ScalarOperator: Scalar) {\n    this.ColumnReference = ColumnRef;\n    this.ScalarOperator = ScalarOperator;\n  }\n}\n\n/** the type that contains the basic statement information */\nexport class BaseStmtInfo {\n  public Batch?: ShowPlanXMLTypeBatchSequenceTypeBatch;\n  public BatchSqlHandle?: string;\n  public CardinalityEstimationModelVersion?: string;\n  public DatabaseContextSettingsId?: number;\n  public ParameterizedPlanHandle?: string;\n  public ParameterizedText?: string;\n  public ParentObjectId?: number;\n  public PlanGuideDB?: string;\n  public PlanGuideName?: string;\n  public QueryHash?: string;\n  public QueryPlanHash?: string;\n  public RetrievedFromCache?: string;\n  public SecurityPolicyApplied?: boolean;\n  public StatementCompId?: number;\n  public StatementEstRows?: number;\n  public StatementId?: number;\n  public StatementOptmEarlyAbortReason?: BaseStmtInfoTypeStatementOptmEarlyAbortReason;\n  public StatementOptmLevel?: string;\n  public StatementParameterizationType?: number;\n  public StatementSqlHandle?: string;\n  public StatementSubTreeCost?: number;\n  public StatementText?: string;\n  public StatementType?: string;\n  public TemplatePlanGuideDB?: string;\n  public TemplatePlanGuideName?: string;\n  public StatementSetOptions?: SetOptions;\n  public Guid: string = Guid.create().toString();\n\n  public CostPercentOfBatch(): number | undefined {\n    if (this.Batch === undefined) {\n      return undefined;\n    }\n\n    if (this.StatementSubTreeCost === undefined) {\n      return undefined;\n    }\n\n    const total =  this.Batch!.Statements\n      .filter((i) => i.StatementSubTreeCost !== undefined)\n      .map((i) => i.StatementSubTreeCost!)\n      .reduce((sum, current) => sum + current);\n\n    return this.StatementSubTreeCost! / total;\n  }\n}\n\nexport type BaseStmtInfoTypeStatementOptmEarlyAbortReason =\n  | 'TimeOut'\n  | 'MemoryLimitExceeded'\n  | 'GoodEnoughPlanFound';\n\nexport class BatchHashTableBuild extends RelOpAction {\n  public BitmapCreator?: boolean;\n}\n\nexport class Bitmap extends RelOpAction {\n  public HashKeys: ColumnReference[];\n\n  public constructor(hashKeys: ColumnReference[]) {\n    super();\n    this.HashKeys = hashKeys;\n  }\n}\n\nexport type CloneAccessScope = 'Primary' | 'Secondary' | 'Both' | 'Either' | 'ExactMatch' | 'Local';\n\nexport class CLRFunction {\n  public Assembly?: string;\n  public Class: string;\n  public Method?: string;\n\n  constructor($class: string) {\n    this.Class = $class;\n  }\n}\n\nexport class Collapse extends RelOpAction {\n  public GroupBy: ColumnReference[];\n\n  constructor(groupBy: ColumnReference[]) {\n    super();\n    this.GroupBy = groupBy;\n  }\n}\n\nexport class ColumnGroup {\n  public Usage: ColumnGroupTypeUsage;\n  public Column: Column[];\n\n  constructor(usage: ColumnGroupTypeUsage, column: Column[]) {\n    this.Usage = usage;\n    this.Column = column;\n  }\n}\n\nexport type ColumnGroupTypeUsage = 'EQUALITY' | 'INEQUALITY' | 'INCLUDE';\n\nexport class ColumnReference {\n  public Alias?: string;\n  public Column: string;\n  public ComputedColumn?: boolean;\n  public Database?: string;\n  public ParameterCompiledValue?: string;\n  public ParameterDataType?: string;\n  public ParameterRuntimeValue?: string;\n  public Schema?: string;\n  public Server?: string;\n  public Table?: string;\n  public ScalarOperator?: Scalar;\n\n  constructor(ColumnName: string) {\n    this.Column = ColumnName;\n  }\n\n  public toString(): string {\n    let out = '';\n    if (this.Database !== undefined) {\n      out += this.Database + '.';\n    }\n\n    if (this.Schema !== undefined) {\n      out += this.Schema + '.';\n    }\n    if (this.Table !== undefined) {\n      out += this.Table + '.';\n    }\n\n    out += this.Column;\n\n    if (this.Alias !== undefined) {\n      out += ' as ' + this.Alias;\n    }\n    return out;\n  }\n}\n\nexport class Column {\n  public ColumnId: number;\n  public Name: string;\n\n  constructor(columnId: number, name: string) {\n    this.ColumnId = columnId;\n    this.Name = name;\n  }\n}\n\nexport type CompareOp =\n  | 'BINARY IS'\n  | 'BOTH NULL'\n  | 'EQ'\n  | 'GE'\n  | 'GT'\n  | 'IS'\n  | 'IS NOT'\n  | 'IS NOT NULL'\n  | 'IS NULL'\n  | 'LE'\n  | 'LT'\n  | 'NE'\n  | 'ONE NULL';\n\nexport class CompareType implements ScalarOp {\n  public CompareOp: CompareOp;\n  public ScalarOperator: Scalar[];\n\n  constructor(compareOp: CompareOp, scalarOperator: Scalar[]) {\n    this.CompareOp = compareOp;\n    this.ScalarOperator = scalarOperator;\n  }\n}\n\nexport class ComputeScalar extends RelOpAction {\n  public ComputeSequence?: boolean;\n}\n\nexport class Concat extends RelOpAction {}\n\nexport class Conditional implements ScalarOp {\n  public Condition: ScalarExpression;\n  public Else: ScalarExpression;\n  public Then: ScalarExpression;\n\n  constructor(condition: ScalarExpression, $else: ScalarExpression, then: ScalarExpression) {\n    this.Condition = condition;\n    this.Else = $else;\n    this.Then = then;\n  }\n}\n\nexport class ConstantScan extends RelOpAction {\n  public Values?: ScalarExpressionList[];\n}\n\nexport class Const implements ScalarOp {\n  public ConstValue: string;\n\n  constructor(constValue: string) {\n    this.ConstValue = constValue;\n  }\n}\n\nexport class Convert implements ScalarOp {\n  public DataType: string;\n  public Implicit: boolean;\n  public Length?: number;\n  public Precision?: number;\n  public Scale?: number;\n  public Style: number;\n  public ScalarOperator: Scalar;\n\n  constructor(dataType: string, implicit: boolean, style: number, scalarOperator: Scalar) {\n    this.DataType = dataType;\n    this.Implicit = implicit;\n    this.Style = style;\n    this.ScalarOperator = scalarOperator;\n  }\n}\n\nexport class CreateIndex extends Rowset {}\n\ninterface CursorPlan {\n  CursorActualType: CursorType;\n  CursorConcurrency: CursorPlanTypeCursorConcurrency;\n  CursorName: string;\n  CursorRequestedType: CursorType;\n  ForwardOnly: boolean;\n  /** The number of occure time depends on how we define the cursor\n   * schema. In shiloh, the OPEN CURSOR and FETCH CURSOR doesn't show any plan and won't raise\n   * error if the cursor doesn't exist. So we must keep the same behaivor, so the minOccurs is 0. If we allow\n   * the declare cursor to be executed in showplan mode, then the open cursor and declare cursor will have\n   * plan in showplan mode, the minOccurs will be 1\n   */\n  Operation?: CursorPlanTypeOperation[];\n}\n\ntype CursorPlanTypeCursorConcurrency = 'Read Only' | 'Pessimistic' | 'Optimistic';\n\ninterface CursorPlanTypeOperation {\n  OperationType: CursorPlanTypeOperationTypeOperationType;\n  QueryPlan: QueryPlan;\n  UDF?: FunctionPlan[];\n}\n\ntype CursorPlanTypeOperationTypeOperationType = 'FetchQuery' | 'PopulateQuery' | 'RefreshQuery';\n\nexport type CursorType = 'Dynamic' | 'FastForward' | 'Keyset' | 'SnapShot';\n\nexport class DefinedValue {\n  public ColumnReference?: ColumnReference[];\n  public ScalarOperator?: Scalar;\n  public ValueVector?: ColumnReference[];\n}\n\nexport type ExecutionModeType = 'Row' | 'Batch';\n\nexport class Filter extends RelOpAction {\n  public StartupExpression: boolean;\n  public Predicate: ScalarExpression;\n  public IsAssert?: boolean;\n\n  constructor(StartupExpression: boolean, Predicate: ScalarExpression) {\n    super();\n    this.StartupExpression = StartupExpression;\n    this.Predicate = Predicate;\n  }\n}\n\nexport class ForeignKeyReferenceCheck {\n  public IndexScan: IndexScan;\n\n  constructor(indexScan: IndexScan) {\n    this.IndexScan = indexScan;\n  }\n}\n\nexport class ForeignKeyReferencesCheck extends RelOpAction {\n  public ForeignKeyReferencesCount?: number;\n  public NoMatchingIndexCount?: number;\n  public PartialMatchingIndexCount?: number;\n  public ForeignKeyReferenceCheck: ForeignKeyReferenceCheck[];\n\n  constructor(foreignKeyReferenceCheck: ForeignKeyReferenceCheck[]) {\n    super();\n    this.ForeignKeyReferenceCheck = foreignKeyReferenceCheck;\n  }\n}\n\n/** Shows the plan for the UDF or stored procedure */\nexport interface FunctionPlan {\n  IsNativelyCompiled?: boolean;\n  ProcName: string;\n  Statements: BaseStmtInfo;\n}\n\nexport class Generic extends RelOpAction {}\n\ninterface GuessedSelectivity {\n  Spatial: ObjectType;\n}\n\n/** Hash spill details */\nexport class HashSpillDetails {\n  public GrantedMemoryKb?: number;\n  public ReadsFromTempDb?: number;\n  public UsedMemoryKb?: number;\n  public WritesToTempDb?: number;\n}\n\nexport class Hash extends RelOpAction {\n  public BitmapCreator?: boolean;\n  public BuildResidual?: ScalarExpression;\n  public HashKeysBuild?: ColumnReference[];\n  public HashKeysProbe?: ColumnReference[];\n  public ProbeResidual?: ScalarExpression;\n  public StarJoinInfo?: StarJoinInfo;\n}\n\nexport class Ident implements ScalarOp {\n  public Table: string;\n  public ColumnReference?: ColumnReference;\n\n  constructor(table: string) {\n    this.Table = table;\n  }\n}\n\nexport type IndexKindType =\n  | 'Heap'\n  | 'Clustered'\n  | 'FTSChangeTracking'\n  | 'FTSMapping'\n  | 'NonClustered'\n  | 'PrimaryXML'\n  | 'SecondaryXML'\n  | 'Spatial'\n  | 'ViewClustered'\n  | 'ViewNonClustered'\n  | 'NonClusteredHash'\n  | 'SelectiveXML'\n  | 'SecondarySelectiveXML';\n\nexport class IndexScan extends Rowset {\n  public DynamicSeek?: boolean;\n  public ForcedIndex?: boolean;\n  public ForceScan?: boolean;\n  public ForceSeek?: boolean;\n  public ForceSeekColumnCount?: number;\n  public Lookup?: boolean;\n  public NoExpandHint?: boolean;\n  public Ordered: boolean;\n  public ScanDirection?: OrderType;\n  public Storage?: StorageType;\n  public IndexedViewInfo?: ObjectType[];\n  public PartitionId?: ColumnReference;\n  public Predicate?: ScalarExpression[];\n  public SeekPredicates?: SeekPredicates;\n\n  constructor(object: ObjectType[], ordered: boolean) {\n    super(object);\n    this.Ordered = ordered;\n  }\n}\n\nexport class Intrinsic implements ScalarOp {\n  public FunctionName: string;\n  public ScalarOperator?: Scalar[];\n\n  constructor(functionName: string) {\n    this.FunctionName = functionName;\n  }\n}\n\nexport type LogicalOperationType =\n  | 'AND'\n  | 'IMPLIES'\n  | 'IS NOT NULL'\n  | 'IS NULL'\n  | 'IS'\n  | 'IsFalseOrNull'\n  | 'NOT'\n  | 'OR'\n  | 'XOR';\n\n/** These are the logical operators to which \"query\"\n * portions of T-SQL statement are translated. Subsequent\n * to that translation, a physical operator is chosen for\n * evaluating each logical operator. The SQL Server query\n * optimizer uses a cost-based approach to decide which\n * physical operator will implement a logical operator.\n */\nexport type LogicalOpType =\n  | 'Aggregate'\n  | 'Anti Diff'\n  | 'Assert'\n  | 'Async Concat'\n  | 'Batch Hash Table Build'\n  | 'Bitmap Create'\n  | 'Clustered Index Scan'\n  | 'Clustered Index Seek'\n  | 'Clustered Update'\n  | 'Collapse'\n  | 'Compute Scalar'\n  | 'Concatenation'\n  | 'Constant Scan'\n  | 'Cross Join'\n  | 'Delete'\n  | 'Deleted Scan'\n  | 'Distinct Sort'\n  | 'Distinct'\n  | 'Distribute Streams'\n  | 'Eager Spool'\n  | 'Filter'\n  | 'Flow Distinct'\n  | 'Foreign Key References Check'\n  | 'Full Outer Join'\n  | 'Gather Streams'\n  | 'Generic'\n  | 'Index Scan'\n  | 'Index Seek'\n  | 'Inner Join'\n  | 'Insert'\n  | 'Inserted Scan'\n  | 'Intersect'\n  | 'Intersect All'\n  | 'Lazy Spool'\n  | 'Left Anti Semi Join'\n  | 'Left Diff'\n  | 'Left Diff All'\n  | 'Left Outer Join'\n  | 'Left Semi Join'\n  | 'Log Row Scan'\n  | 'Merge'\n  | 'Merge Interval'\n  | 'Merge Stats'\n  | 'Parameter Table Scan'\n  | 'Partial Aggregate'\n  | 'Print'\n  | 'Put'\n  | 'Rank'\n  | 'Remote Delete'\n  | 'Remote Index Scan'\n  | 'Remote Index Seek'\n  | 'Remote Insert'\n  | 'Remote Query'\n  | 'Remote Scan'\n  | 'Remote Update'\n  | 'Repartition Streams'\n  | 'RID Lookup'\n  | 'Right Anti Semi Join'\n  | 'Right Diff'\n  | 'Right Diff All'\n  | 'Right Outer Join'\n  | 'Right Semi Join'\n  | 'Segment'\n  | 'Sequence'\n  | 'Sort'\n  | 'Split'\n  | 'Switch'\n  | 'Table-valued function'\n  | 'Table Scan'\n  | 'Top'\n  | 'TopN Sort'\n  | 'UDX'\n  | 'Union'\n  | 'Update'\n  | 'Local Stats'\n  | 'Window Spool'\n  | 'Window Aggregate'\n  | 'Key Lookup'\n  | 'Root'\n  ;\n\nexport class Logical implements ScalarOp {\n  public Operation: LogicalOperationType;\n  public ScalarOperator: Scalar[];\n\n  constructor(operation: LogicalOperationType, scalarOperator: Scalar[]) {\n    this.Operation = operation;\n    this.ScalarOperator = scalarOperator;\n  }\n}\n\n/** For memory consuming relational operators, show fraction of memory grant iterator will use */\ninterface MemoryFractions {\n  Input: number;\n  Output: number;\n}\n\n/** Provide memory grant estimate as well as actual runtime memory grant information.\n * Serial required/desired memory attributes are estimated during query compile time for serial execution.\n * The rest of attributes provide estimates and counters for query execution time considering actual degree of parallelism.\n * SerialRequiredMemory: Required memory in KB if the query runs in serial mode. The query will not start without this memory.\n * SerialDesiredMemory: Memory estimated to fit intermediate results in KB if the query runs in serial mode.\n * RequiredMemory: Required memory in KB for the chosen degree of parallelism. If the query runs in serial mode, this is the same as SerialRequiredMemory.\n * DesiredMemory: Memory estimated to fit intermediate results in KB for the chosen degree of parallelism.  If the query runs in serial mode, this is the same as SerialDesiredMemory.\n * RequestedMemory: Memory in KB which the query requests the memory manager to grant. This can be smaller than sum of RequiredMemory and DesiredMemory if it exceeds the maximum allowed for single query.\n * GrantWaitTime: Time in seconds if the query has to wait for successful memory grant.\n * MaxUsedMemory: Maximum memory in KB used by the query.\n * MaxQueryMemory: Maximum memory in KB allowed for single query.\n */\nexport class MemoryGrant {\n  public DesiredMemory?: number;\n  public GrantedMemory?: number;\n  public GrantWaitTime?: number;\n  public MaxQueryMemory?: number;\n  public MaxUsedMemory?: number;\n  public RequestedMemory?: number;\n  public RequiredMemory?: number;\n  public SerialDesiredMemory: number;\n  public SerialRequiredMemory: number;\n\n  constructor(serialDesiredMemory: number, serialRequiredMemory: number) {\n    this.SerialDesiredMemory = serialDesiredMemory;\n    this.SerialRequiredMemory = serialRequiredMemory;\n  }\n}\n\n/** Provide warning information for memory grant.\n * GrantWarningKind: Warning kind\n * RequestedMemory: Initial grant request in KB\n * GrantedMemory: Granted memory in KB\n * MaxUsedMemory: Maximum used memory grant in KB\n */\nexport class MemoryGrantWarningInfo {\n  public GrantedMemory: number;\n  public GrantWarningKind: MemoryGrantWarningType;\n  public MaxUsedMemory: number;\n  public RequestedMemory: number;\n\n  constructor(grantedMemory: number, grantWarningKind: MemoryGrantWarningType, maxUsedMemory: number, requestedMemory: number) {\n    this.GrantedMemory = grantedMemory;\n    this.GrantWarningKind = grantWarningKind;\n    this.MaxUsedMemory = maxUsedMemory;\n    this.RequestedMemory = requestedMemory;\n  }\n}\n\nexport type MemoryGrantWarningType = 'Excessive Grant' | 'Used More Than Granted' | 'Grant Increase';\n\nexport class Merge extends RelOpAction {\n  public ManyToMany?: boolean;\n  public InnerSideJoinColumns?: ColumnReference[];\n  public OuterSideJoinColumns?: ColumnReference[];\n  public PassThru?: ScalarExpression;\n  public Residual?: ScalarExpression;\n  public StarJoinInfo?: StarJoinInfo;\n}\n\nexport class MissingIndexes {\n  public MissingIndexGroup: MissingIndexGroup[];\n\n  constructor(missingIndexGroup: MissingIndexGroup[]) {\n    this.MissingIndexGroup = missingIndexGroup;\n  }\n}\n\nexport class MissingIndexGroup {\n  public Impact: number;\n  public MissingIndex: MissingIndex[];\n\n  constructor(impact: number, missingIndex: MissingIndex[]) {\n    this.Impact = impact;\n    this.MissingIndex = missingIndex;\n  }\n}\n\nexport class MissingIndex {\n  public Database: string;\n  public Schema: string;\n  public Table: string;\n  public ColumnGroup: ColumnGroup[];\n\n  constructor(database: string, schema: string, table: string, columnGroup: ColumnGroup[]) {\n    this.Database = database;\n    this.Schema = schema;\n    this.Table = table;\n    this.ColumnGroup = columnGroup;\n  }\n\n  public toCreateIndexString(): string {\n    const equalityColumnNames = this.ColumnGroup.filter((i) => i.Usage === 'EQUALITY' || i.Usage === 'INEQUALITY' )[0].Column.map((col) => col.Name);\n\n    const includeColumns = this.ColumnGroup.filter((i) => i.Usage === 'INCLUDE')[0];\n    let includeColumnNames: string[] | undefined;\n    if (includeColumns !== undefined) {\n      includeColumnNames = includeColumns.Column.map((col) => col.Name);\n    }\n\n    const indexName = `IX_${this.Table}_${equalityColumnNames.join('_')}`;\n    let sql = `CREATE NONCLUSTERED INDEX ${indexName} ON ${this.Schema}.${this.Table} (${equalityColumnNames.join(', ')})`;\n\n    if (includeColumnNames !== undefined) {\n      sql += ` INCLUDE (${includeColumnNames.join(', ')})`;\n    }\n\n    return sql;\n  }\n}\n\nexport class MultiAssign implements ScalarOp {\n  public Assigns?: Assign[];\n\n  constructor(assigns?: Assign[]) {\n    this.Assigns = assigns;\n  }\n}\n\nexport class NestedLoops extends RelOpAction {\n  public Optimized: boolean;\n  public WithOrderedPrefetch?: boolean;\n  public WithUnorderedPrefetch?: boolean;\n  public OuterReferences?: ColumnReference[];\n  public PartitionId?: ColumnReference;\n  public PassThru?: ScalarExpression;\n  public Predicate?: ScalarExpression;\n  public ProbeColumn?: ColumnReference;\n\n  public StarJoinInfo?: StarJoinInfo;\n\n  constructor(optimized: boolean) {\n    super();\n    this.Optimized = optimized;\n  }\n}\n\nexport class ObjectType {\n  public Alias?: string;\n  public CloneAccessScope?: CloneAccessScope;\n  public Database?: string;\n  public Filtered?: boolean;\n  public Index?: string;\n  public IndexKind?: IndexKindType;\n  public Schema?: string;\n  public Server?: string;\n  public Storage?: StorageType;\n  public Table?: string;\n  public TableReferenceId?: number;\n\n  public getFullTableName(): string {\n    let out = '';\n    if (this.Database !== undefined) {\n      out += this.Database + '.';\n    }\n\n    if (this.Schema !== undefined) {\n      out += this.Schema + '.';\n    }\n    if (this.Table !== undefined) {\n      out += this.Table;\n    }\n\n    if (this.Alias !== undefined) {\n      out += ' as ' + this.Alias;\n    }\n    return out;\n  }\n}\n/** Provide hardware-dependent properties that affect cost estimate (and hence, query plan choice), as seen by the Query Optimizer.\n * EstimatedAvailableMemoryGrant is an estimate of what amount of memory (KB) will be available for this query at the execution time to request a memory grant from.\n * EstimatedPagesCached is an estimate of how many pages of data will remain cached in the buffer pool if the query needs to read it again.\n * EstimatedAvailableDegreeOfParallelism is an estimate of number of CPUs that can be used to execute the query should the Query Optimizer pick a parallel plan.\n * MaxCompileMemory is the maximum memory in KB allowed for query optimizer to use during compilation.\n */\nexport class OptimizerHardwareDependentProperties {\n  public EstimatedAvailableDegreeOfParallelism?: number;\n  public EstimatedAvailableMemoryGrant: number;\n  public EstimatedPagesCached: number;\n  public MaxCompileMemory?: number;\n\n  constructor(EstimatedAvailableMemoryGrant: number, EstimatedPagesCached: number) {\n    this.EstimatedAvailableMemoryGrant = EstimatedAvailableMemoryGrant;\n    this.EstimatedPagesCached = EstimatedPagesCached;\n  }\n}\n/** List of statistics info used during query optimization */\nexport class OptimizerStatsUsage {\n  public StatisticsInfo: StatsInfo[];\n\n  constructor(statisticsInfo: StatsInfo[]) {\n    this.StatisticsInfo = statisticsInfo;\n  }\n}\n\nexport class OrderBy {\n  public OrderByColumn: OrderByTypeOrderByColumn[];\n\n  constructor(orderByColumn: OrderByTypeOrderByColumn[]) {\n    this.OrderByColumn = orderByColumn;\n  }\n}\n\nexport class OrderByTypeOrderByColumn {\n  public Ascending: boolean;\n  public ColumnReference: ColumnReference;\n\n  constructor(ascending: boolean, columnReference: ColumnReference) {\n    this.Ascending = ascending;\n    this.ColumnReference = columnReference;\n  }\n\n  public toString(): string {\n    if (this.Ascending) {\n      return this.ColumnReference.toString() + ' ASC';\n    }\n\n    return this.ColumnReference.toString() + ' DESC';\n  }\n}\n\nexport type OrderType = 'BACKWARD' | 'FORWARD';\n\nexport class Parallelism extends RelOpAction {\n  public InRow?: boolean;\n  public LocalParallelism?: boolean;\n  public PartitioningType?: PartitionType;\n  public Remoting?: boolean;\n  public Activation?: ParallelismTypeActivation;\n  public BrickRouting?: ParallelismTypeBrickRouting;\n  public HashKeys?: ColumnReference[];\n  public OrderBy?: OrderBy;\n  public PartitionColumns?: ColumnReference[];\n  public Predicate?: ScalarExpression;\n  public ProbeColumn?: ColumnReference;\n}\n\ninterface ParallelismTypeActivation {\n  Type: ParallelismTypeActivationType;\n  Object?: ObjectType;\n}\n\ntype ParallelismTypeActivationType = 'CloneLocation' | 'Resource' | 'SingleBrick' | 'Region';\n\ninterface ParallelismTypeBrickRouting {\n  FragmentIdColumn?: ColumnReference;\n  Object?: ObjectType;\n}\n\ninterface Parameterization {\n  Object: ObjectType[];\n}\n\nexport type PartitionType =\n  | 'Broadcast'\n  | 'Demand'\n  | 'Hash'\n  | 'NoPartitioning'\n  | 'Range'\n  | 'RoundRobin'\n  | 'CloneLocation';\n\n/** Each of the physical operator is an iterator. An iterator\n * can answer three method calls: Init(), GetNext(), and Close().\n * Upon receiving an Init() call, an iterator initializes itself,\n * setting up any data structures if necessary. Upon receiving a\n * GetNext() call, the iterator produces the \"next\" packet of\n * data and gives it to the iterator that made the GetNext() call.\n * To produce the \"next\" packet of data, the iterator may have to\n * make zero or more GetNext() (or even Init()) calls to its\n * children. Upon receiving a Close() call, an iterator performs\n * some clean-up operations and shuts itself down. Typically, an\n * iterator receives one Init() call, followed by many GetNext()\n * calls, and then a single Close() call.\n *\n * The \"query\" portion of a T-SQL statement is typically a tree\n * made up of iterators.\n *\n * Usually, there is a one-to-many mapping among logical operators\n * and physical operators. That is, usually multiple physical operators\n * can implement a logical operator. In some cases in SQL Server,\n * however, a physical operator can implement multiple logical operators.\n */\nexport type PhysicalOp =\n  | 'Adaptive Join'\n  | 'Assert'\n  | 'Batch Hash Table Build'\n  | 'Bitmap'\n  | 'Clustered Index Delete'\n  | 'Clustered Index Insert'\n  | 'Clustered Index Scan'\n  | 'Clustered Index Seek'\n  | 'Clustered Index Update'\n  | 'Clustered Index Merge'\n  | 'Clustered Update'\n  | 'Collapse'\n  | 'Columnstore Index Delete'\n  | 'Columnstore Index Insert'\n  | 'Columnstore Index Merge'\n  | 'Columnstore Index Scan'\n  | 'Columnstore Index Update'\n  | 'Compute Scalar'\n  | 'Concatenation'\n  | 'Constant Scan'\n  | 'Deleted Scan'\n  | 'Filter'\n  | 'Foreign Key References Check'\n  | 'Generic'\n  | 'Hash Match'\n  | 'Index Delete'\n  | 'Index Insert'\n  | 'Index Scan'\n  | 'Index Seek'\n  | 'Index Spool'\n  | 'Index Update'\n  | 'Inserted Scan'\n  | 'Log Row Scan'\n  | 'Merge Interval'\n  | 'Merge Join'\n  | 'Nested Loops'\n  | 'Online Index Insert'\n  | 'Parallelism'\n  | 'Parameter Table Scan'\n  | 'Print'\n  | 'Put'\n  | 'Rank'\n  | 'Remote Delete'\n  | 'Remote Index Scan'\n  | 'Remote Index Seek'\n  | 'Remote Insert'\n  | 'Remote Query'\n  | 'Remote Scan'\n  | 'Remote Update'\n  | 'RID Lookup'\n  | 'Row Count Spool'\n  | 'Segment'\n  | 'Sequence'\n  | 'Sequence Project'\n  | 'Sort'\n  | 'Split'\n  | 'Stream Aggregate'\n  | 'Switch'\n  | 'Table Delete'\n  | 'Table Insert'\n  | 'Table Merge'\n  | 'Table Scan'\n  | 'Table Spool'\n  | 'Table Update'\n  | 'Table-valued function'\n  | 'Top'\n  | 'UDX'\n  | 'Window Aggregate'\n  | 'Window Spool'\n  | 'Key Lookup'\n  | 'Root'\n  ;\n\n/** Shows time statistics for single query execution.\n * CpuTime: CPU time in milliseconds\n * ElapsedTime: elapsed time in milliseconds\n */\nexport class QueryExecTime {\n  public CpuTime: number;\n  public ElapsedTime: number;\n\n  constructor(cpuTime: number, elapsedTime: number) {\n    this.CpuTime = cpuTime;\n    this.ElapsedTime = elapsedTime;\n  }\n}\n\n/** New Runtime information:\n * DegreeOfParallelism\n * EffectiveDegreeOfParallelism: Max parallelism used by columnstore index build\n * MemoryGrant (in kilobytes)\n *\n * New compile time information:\n * mem fractions\n * CachedPlanSize (in kilobytes)\n * CompileTime (in milliseconds)\n * CompileCPU (in milliseconds)\n * CompileMemory (in kilobytes)\n * Parameter values used during query compilation\n * NonParallelPlanReason\n */\nexport class QueryPlan {\n  public CachedPlanSize?: number;\n  public CompileCPU?: number;\n  public CompileMemory?: number;\n  public CompileTime?: number;\n  public ContainsInterleavedExecutionCandidates?: boolean;\n  public DegreeOfParallelism?: number;\n  public EffectiveDegreeOfParallelism?: number;\n  public MemoryGrant?: number;\n  public NonParallelPlanReason?: string;\n  public UsePlan?: boolean;\n  public GuessedSelectivity?: GuessedSelectivity;\n  public MemoryGrantInfo?: MemoryGrant;\n  public MissingIndexes?: MissingIndexes;\n  public OptimizerHardwareDependentProperties?: OptimizerHardwareDependentProperties;\n  public OptimizerStatsUsage?: OptimizerStatsUsage;\n  public ParameterList?: ColumnReference[];\n  public QueryTimeStats?: QueryExecTime;\n  public RelOp: RelOp;\n  public ThreadStat?: ThreadStat;\n  public TraceFlags?: TraceFlagList[];\n  public UnmatchedIndexes?: UnmatchedIndexes;\n  public WaitStats?: WaitStatList;\n  public Warnings?: Warnings;\n\n  constructor(RelOperation: RelOp) {\n    this.RelOp = RelOperation;\n  }\n}\n\nexport class ReceivePlan {\n  public Operation: ReceivePlanTypeOperation[];\n\n  constructor(operation: ReceivePlanTypeOperation[]) {\n    this.Operation = operation;\n  }\n}\n\nexport class ReceivePlanTypeOperation {\n  public OperationType: ReceivePlanTypeOperationTypeOperationType;\n  public QueryPlan: QueryPlan;\n\n  constructor(pperationType: ReceivePlanTypeOperationTypeOperationType, queryPlan: QueryPlan) {\n    this.OperationType = pperationType;\n    this.QueryPlan = queryPlan;\n  }\n}\n\nexport type ReceivePlanTypeOperationTypeOperationType = 'ReceivePlanSelect' | 'ReceivePlanUpdate';\n\nexport class Remote extends RelOpAction {\n  public RemoteDestination?: string;\n  public RemoteObject?: string;\n  public RemoteSource?: string;\n}\n\nexport class RemoteFetch extends Remote {}\n\nexport class RemoteModify extends Remote {\n  public SetPredicate?: ScalarExpression;\n}\n\nexport class RemoteQuery extends Remote {\n  public RemoteQuery?: string;\n}\n\nexport class RemoteRange extends Remote {\n  public SeekPredicates?: SeekPredicates;\n}\n\nexport class Put extends RemoteQuery {\n  public ShuffleColumn?: string;\n  public ShuffleType?: string;\n}\n\n/** Additional information about a rollup. The highest level is the number of group by columns. */\nexport class RollupInfo {\n  public HighestLevel: number;\n  public RollupLevel: RollupLevel[];\n\n  constructor(highestLevel: number, rollupLevel: RollupLevel[]) {\n    this.HighestLevel = highestLevel;\n    this.RollupLevel = rollupLevel;\n  }\n}\n\n/** A level that is output by the rollup.  Level 0 is the base aggregation, equivalent to the statement without 'WITH ROLLUP'.\n * The highest level is the grand total, or group by all.  Level 0 is always output, and at least one higher level.\n */\nexport class RollupLevel {\n  public Level: number;\n\n  constructor(level: number) {\n    this.Level = level;\n  }\n}\n\n/** Runtime information provided from statistics_xml for each relational iterator */\nexport class RunTimeInformation {\n  public RunTimeCountersPerThread: RunTimeInformationTypeRunTimeCountersPerThread[];\n\n  constructor(runTimeCountersPerThread: RunTimeInformationTypeRunTimeCountersPerThread[]) {\n    this.RunTimeCountersPerThread = runTimeCountersPerThread;\n  }\n\n  public GetRunTimeCountersSummary(): RunTimeInformationTypeRunTimeCountersPerThread | undefined {\n    if (this.RunTimeCountersPerThread.length === 0) {\n      return undefined;\n    }\n\n    function undefinedAdd(a: number | undefined, b: number | undefined): number | undefined {\n      if (a === undefined && b === undefined) {\n        return undefined;\n      }\n\n      if (a === undefined && b !== undefined) {\n        return b;\n      }\n\n      if (a !== undefined && b === undefined) {\n        return a;\n      }\n\n      return a! + b!;\n    }\n\n    return this.RunTimeCountersPerThread.reduce((a, b) => {\n      const i = new RunTimeInformationTypeRunTimeCountersPerThread(\n        a.ActualEndOfScans + b.ActualEndOfScans,\n        a.ActualRows + b.ActualRows,\n        0,\n        a.ActualExecutions + b.ActualExecutions);\n\n      i.ActualCPUms = undefinedAdd(a.ActualCPUms, b.ActualCPUms);\n      i.ActualElapsedms = undefinedAdd(a.ActualElapsedms, b.ActualElapsedms);\n      i.ActualLobLogicalReads = undefinedAdd(a.ActualLobLogicalReads, b.ActualLobLogicalReads);\n      i.ActualLobPhysicalReads = undefinedAdd(a.ActualLobPhysicalReads, b.ActualLobPhysicalReads);\n      i.ActualLobReadAheads = undefinedAdd(a.ActualLobReadAheads, b.ActualLobReadAheads);\n      i.ActualLocallyAggregatedRows = undefinedAdd(a.ActualLocallyAggregatedRows, b.ActualLocallyAggregatedRows);\n      i.ActualLogicalReads = undefinedAdd(a.ActualLogicalReads, b.ActualLogicalReads);\n      i.ActualPhysicalReads = undefinedAdd(a.ActualPhysicalReads, b.ActualPhysicalReads);\n      i.ActualReadAheads = undefinedAdd(a.ActualReadAheads, b.ActualReadAheads);\n      i.ActualRebinds = undefinedAdd(a.ActualRebinds, b.ActualRebinds);\n      i.ActualRewinds = undefinedAdd(a.ActualRewinds, b.ActualRewinds);\n      i.ActualRowsRead = undefinedAdd(a.ActualRowsRead, b.ActualRowsRead);\n      i.ActualScans = undefinedAdd(a.ActualScans, b.ActualScans);\n\n      return i;\n    });\n  }\n}\n\nexport class RunTimeInformationTypeRunTimeCountersPerThread {\n  public ActualCPUms?: number;\n  public ActualElapsedms?: number;\n  public ActualEndOfScans: number;\n  public ActualExecutionMode?: ExecutionModeType;\n  public ActualExecutions: number;\n  public ActualJoinType?: PhysicalOp;\n  public ActualLobLogicalReads?: number;\n  public ActualLobPhysicalReads?: number;\n  public ActualLobReadAheads?: number;\n  public ActualLocallyAggregatedRows?: number;\n  public ActualLogicalReads?: number;\n  public ActualPhysicalReads?: number;\n  public ActualReadAheads?: number;\n  public ActualRebinds?: number;\n  public ActualRewinds?: number;\n  public ActualRows: number;\n  public ActualRowsRead?: number;\n  public ActualScans?: number;\n  public Batches?: number;\n  public BrickId?: number;\n  public CloseTime?: number;\n  public FirstActiveTime?: number;\n  public FirstRowTime?: number;\n  public InputMemoryGrant?: number;\n  public IsInterleavedExecuted?: boolean;\n  public LastActiveTime?: number;\n  public LastRowTime?: number;\n  public OpenTime?: number;\n  public OutputMemoryGrant?: number;\n  public SchedulerId?: number;\n  public SegmentReads?: number;\n  public SegmentSkips?: number;\n  public TaskAddr?: number;\n  public Thread: number;\n  public UsedMemoryGrant?: number;\n\n  constructor(actualEndOfScans: number, actualRows: number, thread: number, actualExecutions: number) {\n    this.ActualEndOfScans = actualEndOfScans;\n    this.ActualRows = actualRows;\n    this.Thread = thread;\n    this.ActualExecutions = actualExecutions;\n  }\n}\n\n/** Runtime partition information provided in statistics xml for each relational iterator that support partitioning */\ninterface RunTimePartitionSummary {\n  PartitionsAccessed: RunTimePartitionSummaryTypePartitionsAccessed;\n}\n\nexport class RunTimePartitionSummaryTypePartitionsAccessed {\n  public PartitionCount: number;\n  public PartitionRange?: RunTimePartitionSummaryTypePartitionsAccessedTypePartitionRange[];\n\n  constructor(PartitionCount: number) {\n    this.PartitionCount = PartitionCount;\n  }\n}\n\nexport class RunTimePartitionSummaryTypePartitionsAccessedTypePartitionRange {\n  public End: number;\n  public Start: number;\n\n  constructor(End: number, Start: number) {\n    this.End = End;\n    this.Start = Start;\n  }\n}\n\nexport class ScalarExpressionList implements ScalarOp {\n  public ScalarOperator: Scalar[];\n\n  constructor(scalarOperator: Scalar[]) {\n    this.ScalarOperator = scalarOperator;\n  }\n}\n\nexport class ScalarExpression {\n  public ScalarOperator: Scalar;\n\n  constructor(ScalarOperator: Scalar) {\n    this.ScalarOperator = ScalarOperator;\n  }\n}\n\nexport class ScalarInsert extends Rowset {\n  public DMLRequestSort?: boolean;\n  public SetPredicate?: ScalarExpression;\n}\n\nexport class ScalarSequence implements ScalarOp {\n  public FunctionName: string;\n\n  constructor(functionName: string) {\n    this.FunctionName = functionName;\n  }\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface ScalarOp {}\n\n/** should not be used */\nexport class NotImplementedScalarOp implements ScalarOp {\n\n}\n\n/** Scalar expression. If root of scalar tree contains semantically equivalent string representation of entire expression */\nexport class Scalar {\n  public ScalarString?: string;\n  public Operation: ScalarOp;\n\n  constructor(Operation: ScalarOp) {\n    this.Operation = Operation;\n  }\n}\n\nexport class ScanRange {\n  public ScanType: CompareOp;\n  public RangeColumns: ColumnReference[];\n  public RangeExpressions: ScalarExpression[];\n\n  constructor(scanType: CompareOp, rangeColumns: ColumnReference[], rangeExpressions: ScalarExpression[]) {\n    this.ScanType = scanType;\n    this.RangeColumns = rangeColumns;\n    this.RangeExpressions = rangeExpressions;\n  }\n\n  public ScanTypeToString(): string {\n    switch (this.ScanType) {\n      case 'EQ': return '=';\n      case 'GE': return '>=';\n      case 'GT': return '>';\n      case 'LE': return '<=';\n      case 'LT': return '<';\n      case 'NE': return '!=';\n      default: return this.ScanType;\n    }\n  }\n}\n\nexport class SeekPredicateNew {\n  public SeekKeys: SeekPredicate[];\n\n  constructor(seekKeys: SeekPredicate[]) {\n    this.SeekKeys = seekKeys;\n  }\n}\n\nexport class SeekPredicatePart {\n  public SeekPredicateNew: SeekPredicateNew[];\n\n  constructor(seekPredicateNew: SeekPredicateNew[]) {\n    this.SeekPredicateNew = seekPredicateNew;\n  }\n}\n\nexport class SeekPredicates {\n  public SeekPredicate?: SeekPredicate[];\n  public SeekPredicateNew?: SeekPredicateNew[];\n  public SeekPredicatePart?: SeekPredicatePart[];\n}\n\nexport class SeekPredicate {\n  public EndRange?: ScanRange;\n  public IsNotNull?: ColumnReference;\n  public Prefix?: ScanRange;\n  public StartRange?: ScanRange;\n\n  public toStrings(): Array<{key: string, value: string}> {\n    const result: Array<{key: string, value: string}> = [];\n    if (this.Prefix !== undefined) {\n      if (this.Prefix.RangeColumns.length === 1 && this.Prefix.RangeExpressions.length === 1) {\n        result.push({ key: 'Prefix', value: this.Prefix.RangeColumns[0].toString() + ' ' + this.Prefix.ScanTypeToString() + ' ' + this.Prefix.RangeExpressions[0].ScalarOperator.ScalarString });\n      }\n    }\n\n    if (this.StartRange !== undefined) {\n      if (this.StartRange.RangeColumns.length === 1 && this.StartRange.RangeExpressions.length === 1) {\n        result.push({ key: 'Start', value: this.StartRange.RangeColumns[0].toString() + ' ' + this.StartRange.ScanTypeToString() + ' ' + this.StartRange.RangeExpressions[0].ScalarOperator.ScalarString });\n      }\n    }\n\n    if (this.EndRange !== undefined) {\n      if (this.EndRange.RangeColumns.length === 1 && this.EndRange.RangeExpressions.length === 1) {\n        result.push({ key: 'End', value: this.EndRange.RangeColumns[0].toString() + ' ' + this.EndRange.ScanTypeToString() + ' ' + this.EndRange.RangeExpressions[0].ScalarOperator.ScalarString });\n      }\n    }\n\n    if (this.IsNotNull !== undefined) {\n      result.push({ key: 'Is Not Null', value: this.IsNotNull!.toString() });\n    }\n\n    return result;\n  }\n}\n\nexport class Segment extends RelOpAction {\n  public GroupBy: ColumnReference[];\n  public SegmentColumn: ColumnReference;\n\n  constructor(groupBy: ColumnReference[], segmentColumn: ColumnReference) {\n    super();\n    this.GroupBy = groupBy;\n    this.SegmentColumn = segmentColumn;\n  }\n\n}\n\nexport class Sequence extends RelOpAction {}\n\n/** The set options that affects query cost */\nexport class SetOptions {\n  public ANSI_NULLS?: boolean;\n  public ANSI_PADDING?: boolean;\n  public ANSI_WARNINGS?: boolean;\n  public ARITHABORT?: boolean;\n  public CONCAT_NULL_YIELDS_NULL?: boolean;\n  public NUMERIC_ROUNDABORT?: boolean;\n  public QUOTED_IDENTIFIER?: boolean;\n\n  constructor(\n    ANSI_NULLS?: boolean,\n    ANSI_PADDING?: boolean,\n    ANSI_WARNINGS?: boolean,\n    ARITHABORT?: boolean,\n    CONCAT_NULL_YIELDS_NULL?: boolean,\n    NUMERIC_ROUNDABORT?: boolean,\n    QUOTED_IDENTIFIER?: boolean,\n  ) {\n    this.ANSI_NULLS = ANSI_NULLS;\n    this.ANSI_PADDING = ANSI_PADDING;\n    this.ANSI_WARNINGS = ANSI_WARNINGS;\n    this.ARITHABORT = ARITHABORT;\n    this.CONCAT_NULL_YIELDS_NULL = CONCAT_NULL_YIELDS_NULL;\n    this.NUMERIC_ROUNDABORT = NUMERIC_ROUNDABORT;\n    this.QUOTED_IDENTIFIER = QUOTED_IDENTIFIER;\n  }\n}\n\nexport class SetPredicateElement extends ScalarExpression {\n  public SetPredicateType?: SetPredicateType;\n}\n\nexport type SetPredicateType = 'Update' | 'Insert';\n\nexport class ShowPlanXMLTypeBatchSequenceTypeBatch {\n  public Statements: BaseStmtInfo[];\n\n  constructor(Statements: BaseStmtInfo[]) {\n    this.Statements = Statements;\n\n    for (const statement of this.Statements) {\n      statement.Batch = this;\n    }\n  }\n\n  public TotalCost(): number {\n    let sum = 0;\n    for (const child of this.Statements) {\n      if (child.StatementSubTreeCost !== undefined) {\n        sum += child.StatementSubTreeCost!;\n      }\n    }\n\n    return sum;\n  }\n}\n\nexport class SimpleIteratorOneChild extends RelOpAction {}\n\nexport class SimpleUpdate extends Rowset {\n  public DMLRequestSort?: boolean;\n  public SeekPredicate?: SeekPredicate;\n  public SeekPredicateNew?: SeekPredicateNew;\n  public SetPredicate?: ScalarExpression;\n}\n\n/** Sort spill details */\nexport class SortSpillDetails {\n  public GrantedMemoryKb?: number;\n  public ReadsFromTempDb?: number;\n  public UsedMemoryKb?: number;\n  public WritesToTempDb?: number;\n}\n\nexport class Sort extends RelOpAction {\n  public Distinct: boolean;\n  public OrderBy: OrderBy;\n  public PartitionId?: ColumnReference;\n\n  constructor(distinct: boolean, orderBy: OrderBy) {\n    super();\n    this.Distinct = distinct;\n    this.OrderBy = orderBy;\n  }\n}\n\n/** Spill warning information */\nexport class SpillToTempDb {\n  public SpilledThreadCount?: number;\n  public SpillLevel?: number;\n}\n\nexport class Split extends RelOpAction {\n  public ActionColumn?: ColumnReference;\n}\n\nexport class Spool extends RelOpAction {\n  public PrimaryNodeId?: number;\n  public Stack?: boolean;\n  public SeekPredicate?: SeekPredicate;\n  public SeekPredicateNew?: SeekPredicateNew;\n}\n\n/** Additional information about Star Join structure. */\nexport class StarJoinInfo {\n  public OperationType: StarJoinInfoTypeOperationType;\n  public Root?: boolean;\n\n  constructor(operationType: StarJoinInfoTypeOperationType) {\n    this.OperationType = operationType;\n  }\n}\n\nexport type StarJoinInfoTypeOperationType =\n  | 'Fetch'\n  | 'Index Intersection'\n  | 'Index Filter'\n  | 'Index Lookup';\n\n/** Information on single statistics used during query optimization.\n * Database : name of the database\n * Schema : name of the schema\n * Table : name of the table\n * Statistics : name of the statistics\n * ModificationCount : number of modifications since the last update\n * SamplingPercent : statistics sampling percentage\n * LastUpdate : date when the statistics was updated\n */\nexport class StatsInfo {\n  public Database?: string;\n  public LastUpdate?: Date;\n  public ModificationCount: number;\n  public SamplingPercent: number;\n  public Schema?: string;\n  public Statistics: string;\n  public Table?: string;\n\n  constructor(modificationCount: number, samplingPercent: number, statistics: string) {\n    this.ModificationCount = modificationCount;\n    this.SamplingPercent = samplingPercent;\n    this.Statistics = statistics;\n  }\n}\n\n/** Complex statement type that is constructed by a condition, a then clause and an optional else clause. */\nexport class StmtCond extends BaseStmtInfo {\n  public Condition: StmtCondTypeCondition;\n  public Else?: StmtCondTypeElse;\n  public Then: StmtCondTypeThen;\n\n  constructor(condition: StmtCondTypeCondition, then: StmtCondTypeThen) {\n    super();\n    this.Condition = condition;\n    this.Then = then;\n  }\n}\n\nexport class StmtCondTypeCondition {\n  public QueryPlan?: QueryPlan;\n  public UDF?: FunctionPlan[];\n}\n\nexport class StmtCondTypeElse {\n  public Statements: BaseStmtInfo;\n\n  constructor(statements: BaseStmtInfo) {\n    this.Statements = statements;\n  }\n}\nexport class StmtCondTypeThen {\n  public Statements: BaseStmtInfo;\n\n  constructor(statements: BaseStmtInfo) {\n    this.Statements = statements;\n  }\n}\n\n/** The cursor type that might have one or more cursor operations, used in DECLARE CURSOR, OPEN CURSOR and FETCH CURSOR */\nexport class StmtCursor extends BaseStmtInfo {\n  public CursorPlan: CursorPlan;\n\n  constructor(cursorPlan: CursorPlan) {\n    super();\n    this.CursorPlan = cursorPlan;\n  }\n}\n\n/** The cursor type that might have one or more cursor operations, used in DECLARE CURSOR, OPEN CURSOR and FETCH CURSOR */\nexport class StmtReceive extends BaseStmtInfo {\n  public ReceivePlan: ReceivePlan;\n\n  constructor(receivePlan: ReceivePlan) {\n    super();\n    this.ReceivePlan = receivePlan;\n  }\n}\n\n/** The simple statement that may or may not contain query plan, UDF plan or Stored Procedure plan */\nexport class StmtSimple extends BaseStmtInfo {\n  public QueryPlan?: QueryPlan;\n  public StoredProc?: FunctionPlan;\n  public UDF?: FunctionPlan[];\n}\n\n/** Use database statement */\nexport class StmtUseDb extends BaseStmtInfo {\n  public Database: string;\n\n  constructor(Database: string) {\n    super();\n    this.Database = Database;\n  }\n}\n\nexport type StorageType = 'RowStore' | 'ColumnStore' | 'MemoryOptimized';\n\nexport class StreamAggregate extends RelOpAction {\n  public GroupBy?: ColumnReference[];\n  public RollupInfo?: RollupInfo;\n}\n\nexport type SubqueryOperationType =\n  | 'EQ ALL'\n  | 'EQ ANY'\n  | 'EXISTS'\n  | 'GE ALL'\n  | 'GE ANY'\n  | 'GT ALL'\n  | 'GT ANY'\n  | 'IN'\n  | 'LE ALL'\n  | 'LE ANY'\n  | 'LT ALL'\n  | 'LT ANY'\n  | 'NE ALL'\n  | 'NE ANY';\n\nexport class Subquery implements ScalarOp {\n  public Operation: SubqueryOperationType;\n  public ScalarOperator?: Scalar;\n  public RelOp: RelOp;\n\n  constructor(operation: SubqueryOperationType, relop: RelOp) {\n    this.Operation = operation;\n    this.RelOp = relop;\n  }\n}\n\nexport class Switch extends Concat {\n  public Predicate?: ScalarExpression;\n}\n\nexport class TableScan extends Rowset {\n  public ForcedIndex?: boolean;\n  public ForceScan?: boolean;\n  public NoExpandHint?: boolean;\n  public Ordered: boolean;\n  public Storage?: StorageType;\n  public IndexedViewInfo?: ObjectType[];\n  public PartitionId?: ColumnReference;\n  public Predicate?: ScalarExpression;\n\n  constructor(object: ObjectType[], ordered: boolean) {\n    super(object);\n    this.Ordered = ordered;\n  }\n}\n\n/** Typical user defined table valued function doesn't have a relational child element. If a relational child\n * is present then the operator is a special internal table valued function that hosts native code.\n */\nexport class TableValuedFunction extends RelOpAction {\n  public Object?: ObjectType;\n  public ParameterList?: ScalarExpressionList;\n  public Predicate?: ScalarExpression;\n}\n\n/** Information on how parallel threads are reserved on NUMA node\n * NodeId: ID of NUMA node where this query is chosen to run\n * ReservedThreads: number of reserved parallel thread on this NUMA node\n */\nexport class ThreadReservation {\n  public NodeId: number;\n  public ReservedThreads: number;\n\n  constructor(NodeId: number, ReservedThreads: number) {\n    this.NodeId = NodeId;\n    this.ReservedThreads = ReservedThreads;\n  }\n}\n\n/** Information on parallel thread usage.\n * Branches: Attribute. total number of concurrent branches of query plan.\n * Query would need additional worker threads of at least (Branches)* (Degree of Parallelism)\n * UsedThreads: Attribute maximum number of used parallel threads.  This is available only for statistics XML\n * Then follows a list of one or more ThreadReservation elements.\n */\nexport class ThreadStat {\n  public Branches: number;\n  public UsedThreads?: number;\n  public ThreadReservation?: ThreadReservation[];\n\n  constructor(Branches: number) {\n    this.Branches = Branches;\n  }\n}\n\nexport class TopSort extends Sort {\n  public Rows: number;\n  public WithTies?: boolean;\n\n  constructor(rows: number, distinct: boolean, orderBy: OrderBy) {\n    super(distinct, orderBy);\n    this.Rows = rows;\n  }\n}\n\nexport class Top extends RelOpAction {\n  public IsPercent?: boolean;\n  public RowCount?: boolean;\n  public Rows?: number;\n  public WithTies?: boolean;\n  public OffsetExpression?: ScalarExpression;\n  public TieColumns?: ColumnReference[];\n  public TopExpression?: ScalarExpression;\n}\n\n/** Collection of trace flags used in SQL engine. */\ninterface TraceFlagList {\n  IsCompileTime: boolean;\n  TraceFlag: TraceFlag[];\n}\n\nexport type TraceFlagScopeType = 'Global' | 'Session';\n\n/** Describe a trace flag used in SQL engine. */\ninterface TraceFlag {\n  Scope: TraceFlagScopeType;\n  Value: number;\n}\n\nexport class UDAggregate implements ScalarOp {\n  public Distinct: boolean;\n  public ScalarOperator?: Scalar[];\n  public UDAggObject?: ObjectType;\n\n  constructor(distinct: boolean) {\n    this.Distinct = distinct;\n  }\n}\n\nexport class UDF implements ScalarOp {\n  public FunctionName: string;\n  public IsClrFunction?: boolean;\n  public CLRFunction?: CLRFunction;\n  public ScalarOperator?: Scalar[];\n\n  constructor(functionName: string) {\n    this.FunctionName = functionName;\n  }\n}\n\nexport class UDTMethod implements ScalarOp {\n  public CLRFunction?: CLRFunction;\n  public ScalarOperator?: Scalar[];\n}\n\nexport class UDX extends RelOpAction {\n  public UDXName: string;\n  public UsedUDXColumns?: ColumnReference[];\n\n  constructor(udxName: string) {\n    super();\n    this.UDXName = udxName;\n  }\n}\n\ninterface UnmatchedIndexes {\n  Parameterization: Parameterization;\n}\n\nexport class Update extends Rowset {\n  public DMLRequestSort?: boolean;\n  public WithOrderedPrefetch?: boolean;\n  public WithUnorderedPrefetch?: boolean;\n  public ActionColumn?: ColumnReference;\n  public OriginalActionColumn?: ColumnReference;\n  public ProbeColumn?: ColumnReference;\n  public SetPredicate?: SetPredicateElement[];\n}\n\n/** A list of query wait statistics. */\nexport class WaitStatList {\n  public Wait?: WaitStat[];\n}\n\n/** Wait statistics during one query execution.\n * WaitType: Name of the wait\n * WaitTimeMs: Wait time in milliseconds\n * WaitCount: Number of waits\n */\nexport class WaitStat {\n  public WaitCount: number;\n  public WaitTimeMs: number;\n  public WaitType: string;\n\n  constructor(waitCount: number, waitTimeMs: number, waitType: string) {\n    this.WaitCount = waitCount;\n    this.WaitTimeMs = waitTimeMs;\n    this.WaitType = waitType;\n  }\n}\n\n/** Query wait information */\nexport class WaitWarning {\n  public WaitTime?: number;\n  public WaitType: WaitWarningTypeWaitType;\n\n  constructor(waitType: WaitWarningTypeWaitType) {\n    this.WaitType = waitType;\n  }\n}\n\nexport type WaitWarningTypeWaitType = 'Memory Grant';\n\n/** List of all possible iterator or query specific warnings (e.g. hash spilling, no join predicate) */\nexport class Warnings {\n  public FullUpdateForOnlineIndexBuild?: boolean;\n  public NoJoinPredicate?: boolean;\n  public SpatialGuess?: boolean;\n  public UnmatchedIndexes?: boolean;\n  public ColumnsWithNoStatistics?: ColumnReference[];\n  public HashSpillDetails?: HashSpillDetails[];\n  public MemoryGrantWarning?: MemoryGrantWarningInfo[];\n  public PlanAffectingConvert?: AffectingConvertWarning[];\n  public SortSpillDetails?: SortSpillDetails[];\n  public SpillToTempDb?: SpillToTempDb[];\n  public Wait?: WaitWarning[];\n}\nexport class WindowAggregate extends RelOpAction {}\n\nexport class Window extends RelOpAction {}\n","export class Convert {\r\n  public static GetFloat(element: Element, attribute: string): number | undefined {\r\n    const input = element.getAttribute(attribute);\r\n    if (input === null || input === '') { return undefined; }\r\n\r\n    return parseFloat(input);\r\n  }\r\n\r\n  public static GetInt(element: Element, attribute: string): number | undefined {\r\n    const input = element.getAttribute(attribute);\r\n    if (input === null || input === '') { return undefined; }\r\n\r\n    return parseInt(input, 10);\r\n  }\r\n\r\n  public static GetString(element: Element, attribute: string): string | undefined {\r\n    const input = element.getAttribute(attribute);\r\n    if (input === null || input === '') { return undefined; }\r\n\r\n    return input;\r\n  }\r\n\r\n  public static GetBoolean(element: Element, attribute: string): boolean | undefined {\r\n    const input = element.getAttribute(attribute);\r\n    if (input === null || input === '') { return undefined; }\r\n\r\n    return input !== 'false';\r\n  }\r\n\r\n  public static GetDate(element: Element, attribute: string): Date | undefined {\r\n    const input = element.getAttribute(attribute);\r\n    if (input === null || input === '') { return undefined; }\r\n\r\n    return new Date(Date.parse(input));\r\n  }\r\n}\r\n"],"sourceRoot":""}